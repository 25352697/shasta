<!DOCTYPE html>
<html>

<head>
<link rel=stylesheet href=style.css />
<link rel=icon href=CZI-new-logo.png />
</head>

<body>
    <nav role="navigation">
        <ul>
            <a class="main-nav" href=index.html><li >Shasta</li></a>
                <a href=QuickStart.html><li>Quick Start</li></a>
                
                <li aria-haspopup="true"> How to
                <ul class="dropdown" aria-label="submenu">
                <a href=Running.html><li>Run an assembly</li></a>
                <a href=Performance.html><li>Maximize assembly performance</li></a>
                <a href=BuildingFromSource.html><li>Build the code from source</li></a>
                <a href=InspectingResults.html><li>Inspect or debug assembly results</li></a>
                <a href=Contributing.html><li>Contribute to Shasta</li></a>
                <a href=ReportingBugs.html><li>Report problems or ask questions</li></a>
                </ul>
            </li>
            <li aria-haspopup="true"> About
                    <ul class="dropdown" aria-label="submenu">
                            <a href=Motivation.html><li>Motivation</li></a>
                            <a href=CurrentStatus.html><li>Current status</li></a>
                            <a href=SupportedPlatforms.html><li>Supported platforms</li></a>
                            <a href=Acknowledgments.html><li>Acknowledgments</li></a>
                            <a href=ComputationalMethods.html><li>Computational methods</li></a>
                            <a href=Compatibility.html><li>Compatibility across releases</li></a>
    
                    </ul>
                </li>
    
        </ul>
    </nav>
    <main>
    
    
    
<h1>Computational methods</h1>

<h2>Oxford Nanopore reads</h2>

<p>
The Shasta assembler is being developed with the goal of assembling 
<a href="https://nanoporetech.com">Oxford Nanopore</a> reads,
although it can also be used to assemble other types of long reads
such as those generated by <a href="https://www.pacb.com/">Pacific Biosciences</a>
sequencing platforms.

<p>
Oxford Nanopore reads are rapidly evolving in characteristics, 
and the Shasta assembler was developed targeting reads obtained
using the sequencing protocols in used in the nanopore group at
University of California at Santa Cruz in early 2019.
These reads can be characterized as follows:

<ul>
<li>Typical length around 50 Kb, with just a few percent of coverage
in reads below 10 Kb and 10% or more of coverage in reads longer than 100 Kb.
<li>High error rate of raw reads, with sequence identity around 90%
or, equivalently, a raw read error rate around 10%.
<li>The dominant error mode consists of errors in the length of homopolymer runs
at all lengths. Errors in short homopolymer runs (lengths 1-5)
are particularly deleterious due to the high frequency 
of such runs.
</ul>




<h2>Computational challenges</h2>
<p>
Due to their length, Oxford Nanopore reads have
unique value for <i>de novo</i>
assembly. However a successful approach needs
to deal with the high error rate.

<p>Traditional approaches to <i>de novo</i> assembly typically
rely on selecting a k-mer length that satisfies the following:

<ul>
<li>K-mers of the selected length are reasonably unique
in the target genome. For human assemblies, this typically means
k &#10886; 30.
<li>Most k-mers of the selected length are error free in the
target reads. This means that k must be significantly less
than the inverse of the error rate.
</ul>

<p>
For many sequencing technolgies the above conditions 
are satisfied for k around 30.
But for our target reads, with an error rate around 10%,
most 30-mers contains errors, and therefore 
assembly algorithms based on using such k-mers become unfeasible.

<p>
A possible approach consists of adding a preliminary error correction
step in which reads are aligned to each other and corrected based on consensus,
and then presenting to the assembler the corrected reads,
which hopefully have a much lower error rate. 
But such approaches tends to be slow, and in addition 
any errors made in the error correction step
are permanent and cannot be fixed during the assembly process.


<h2>Read representation in the Shasta assembler</h2>

<p> 
The computational techniques used in the Shasta assembler
rely on representing the sequence of input reads in a way
that the reduces the effect of errors on 
the <i>de novo</i> assembly process:
<ul>
<li>
The sequence of input reads is represented using 
<a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>.
<li>
In many assembly steps, the sequence of input reads is described
by using occurrences of a pre-determined subset of short k-mers
(k &#8776; 10 in run-encoding)
called <i>markers</i>.
</ul>

The next two sections expand on these two methods of
representing the input reads.


<h2>Run-length encoding of input reads</h2>

<p>
With <a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>,
the sequence of each input read is represented as a sequence of bases,
each with a repeat count that says how many times each of the bases is repeated. 
For example, the following read

<pre>
CGATTTAAGTTA
</pre>

is represented as follows using run-length encoding:

<pre>
CGATAGTA
11132121
</pre>


<p>
Using run-length encoding makes the assembly process
less sensitive to errors in the length of homopolymer runs,
which are the most common type of errors in Oxford Nanopore reads.
For example, consider these two reads:

<pre>
CGATTTAAGTTA
CGATTAAGGGTTA
</pre>

Using their raw representation above, these reads can aligned like this:

<pre>
CGATTTAAG--TTA
CGATT-AAGGGTTA
</pre>

Aligning the second read to the first required a deletion and two insertions.
But in run-length encoding, the two reads become:

<pre>
CGATAGTA
11132121
CGATAGTA
11122321
</pre>

The sequence portions are now identical and can be aligned trivially
and exactly, without any insertions or deletions:

<pre>
CGATAGTA
CGATAGTA
</pre>

The differences between the two reads only appear in the repeat counts:

<pre>
11132121
11122321
   * *
</pre>

<p>
The Shasta assembler uses one byte to represent repeat counts,
and as a result it only represents repeat counts
between 1 and 255. If a read contains more than 255
consecutive bases, it is discarded on input.
Such reads are extremely rare, and the occurrence of such a large
number of repeated bases is probably a symptom
that something is wrong with the read anyway.



<h5>Some properties of base sequences in run-length encoding</h5>
<ul>

<li>In the sequence portion of the run-length encoding,
consecutive bases always are always distinct. If they were not, the second one
would be removed from the run-length encoded sequence,
while increasing the repeat count for the first one.

<li>
With ordinary base sequences, the number of distinct k-mers of length k is 4<sup>k</sup>.
But run-length base sequences, the number of distinct k-mers of length k
is 4&#215;3<sup>k-1</sup>.
This is a consequence of the previous bullet.

<li>The run-length sequence is generally shorter than the raw sequence,
and cannot be longer. For a long random sequence, the number
of bases in the run-length representation is 3/4  of the number of bases
in the raw representation.

</ul>



<h2>Markers</h2>

<p>
Even with run-length encoding, error in input reads are still frequent.
To further reduce sensitivity to errors, and also to speed up
some of the computational steps in the assembly process,
the Shasta assembler also uses a read representation
based on <i>markers</i>. Markers are 
occurrences in reads of a pre-determined subset of short k-mers.
By default, Shasta uses for this purpose k-mers with k=10 in run-length
encoding, corresponding to an average approximately 13 bases
in raw read representation. 

<p>Just for the purposes of illustration, consider a description
using markers of length 3 in run-length encoding.
There is a total 4&times;3<sup>2</sup> = 36 distinct such markers. 
We arbitrarily choose the following fixed subset of the 36, and we assign an id 
to each of the kmers in the subset:

<table class="small-table">
<tr><td><code>TGC</code><td>0
<tr><td><code>GCA</code><td>1
<tr><td><code>GAC</code><td>2
<tr><td><code>CGC</code><td>3
</table>

<p>
Consider now the following portion of a read in run-length representation (here, the
repeat counts are irrelevant and so they are omitted):
<pre>
CGACACGTATGCGCACGCTGCGCTCTGCAGC
 GAC        GCA   TGC     GCA
                    CGC
</pre>
Occurrences of the k-mers defined in the table above are shown
and define the markers in this read. Note that markers
can overlap. Using the marker ids defined in the table above,
we can summarize the sequence of this read portion as follows:

<pre>
2 1 0 3 1
</pre>

This is the marker representation of the read portion above.
It just includes the sequence of markers occurring in the read,
not their positions.

<p>
Note that the marker representation loses information,
as it is not possible to reconstruct the complete initial sequence
from the marker representation. This also means that the 
marker representation is insensitive to errors in the sequence
portions that don't belong to any markers.

<p>
The Shasta assembler uses a random choice of the k-mers to be used
as markers. The length of the markers k is controlled by
assembly parameter <code>Kmers.k</code> with a default value of 10.
Each k-mer is randomly choosen to be used as a marker
with probability determined by assembly parameter 
<code>Kmers.probability</code> with a default value of 0.1.
With these default values, the total number of distinct
markers is approximately 0.1&times;4<sup>10</sup>&times;3<sup>9</sup>&#8776;7900.

<p>
The only constraint used in selecting k-mers to be used as markers
is that if a k-mer is a marker, its reverse
complement should also be a marker. This makes it easy to construct
the marker representation of the reverse complement
of a read from the
marker representation of the original read.
It also ensures strand symetry in some of the computational steps.

<p>
It is possible that the random selection of markers
is not optimal, and it may best to select the markers
based on their frequency in the input reads. 
This possibility has not yet been investigated.

<p>
Below is the run-length representation of a portion of a read
and its markers, as displayed by the Shasta http server.

<p>
<img class="fit-in-main" src=Markers.png>



<h3>Marker alignments</h3>
<p>
The marker representation of a read is a sequence 
in an alphabet consisting of the marker ids.
This sequence is much shorter than the original sequence of the read,
but uses a much larger alphabet.
For example, 
with default Shasta assembly parameters, the marker representation
is 10 times shorter than the run-length encoded read sequence,
or about 13 times shorter than the raw read sequence.
Its alphabet has around 8000
symbols, many more than the 4 symbols that the original 
read sequence uses.  

<p>
Because the marker representation of a read is a sequence,
we can compute an alignment of two reads directly in
marker representation. Computing an alignment in this way
has several advantages:
<ul>
<li>The shorter sequences and larger alphabet make
the alignment much faster to compute.
<li>The alignment is insensitive to read errors in
the portions that are not covered by any marker.
</ul>


<p>
Given 
read X with n<sub>X</sub> markers X<sub>i</sub> (i=0,...n<sub>X</sub>-1)
and 
read Y with n<sub>Y</sub> markers Y<sub>j</sub> (j=0,...n<sub>Y</sub>-1),
the alignment matrix A<sub>ij</sub> is a n<sub>X</sub>&times;n<sub>Y</sub>
matrix with elements
<p>
A<sub>ij</sub> = <span style='font-family:serif'>&delta;</span><sub>X<sub>i</sub>Y<sub>j</sub></sub>
<p>
or, in words, A<sub>ij</sub> is 1 if X<sub>i</sub>=Y<sub>j</sub>
and 0 otherwise.

In portion where the reads X and Y are perfectly aligned,
the matrix consists of a matrix diagonal set to 1 with everything
else set to 0, except for occasional 1's that appear by chance.
These occasional 1's are rare because of the large alphabet.

<p>
The picture below shows a portion of the alignment matrix
of two reads, in marker representation, as displayed by the Shasta
http server.

<p>




<br><br><hr>
<b>This page is work in progress...</b>




</main>


</body>
</html>


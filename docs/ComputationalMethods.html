<!DOCTYPE html>
<html>

<head>
<link rel=stylesheet href=style.css />
<link rel=icon href=CZI-new-logo.png />
</head>

<body>
    <nav role="navigation">
        <ul>
            <a class="main-nav" href=index.html><li >Shasta</li></a>
                <a href=QuickStart.html><li>Quick Start</li></a>
                
                <li aria-haspopup="true"> How to
                <ul class="dropdown" aria-label="submenu">
                <a href=Running.html><li>Run an assembly</li></a>
                <a href=Performance.html><li>Maximize assembly performance</li></a>
                <a href=BuildingFromSource.html><li>Build the code from source</li></a>
                <a href=InspectingResults.html><li>Inspect or debug assembly results</li></a>
                <a href=Contributing.html><li>Contribute to Shasta</li></a>
                <a href=ReportingBugs.html><li>Report problems or ask questions</li></a>
                </ul>
            </li>
            <li aria-haspopup="true"> About
                    <ul class="dropdown" aria-label="submenu">
                            <a href=Motivation.html><li>Motivation</li></a>
                            <a href=CurrentStatus.html><li>Current status</li></a>
                            <a href=SupportedPlatforms.html><li>Supported platforms</li></a>
                            <a href=Acknowledgments.html><li>Acknowledgments</li></a>
                            <a href=ComputationalMethods.html><li>Computational methods</li></a>
                            <a href=Compatibility.html><li>Compatibility across releases</li></a>
    
                    </ul>
                </li>
    
        </ul>
    </nav>
    <main>
    
    
    
<h1>Computational methods</h1>

<h2>Oxford Nanopore reads</h2>

<p>
The Shasta assembler is being developed with the goal of assembling 
<a href="https://nanoporetech.com">Oxford Nanopore</a> reads,
although it can also be used to assemble other types of long reads
such as those generated by <a href="https://www.pacb.com/">Pacific Biosciences</a>
sequencing platforms.

<p>
Oxford Nanopore reads are rapidly evolving in characteristics, 
and the Shasta assembler was developed targeting reads obtained
using the sequencing protocols in used in the nanopore group at
University of California at Santa Cruz in early 2019.
These reads can be characterized as follows:

<ul>
<li>Typical length around 50 Kb, with just a few percent of coverage
in reads below 10 Kb and 10% or more of coverage in reads longer than 100 Kb.
<li>High error rate of raw reads, with sequence identity around 90%
or, equivalently, a raw read error rate around 10%.
<li>The dominant error mode consists of errors in the length of homopolymer runs
at all lengths. Errors in short homopolymer runs (lengths 1-5)
are particularly deleterious due to the high frequency 
of such runs.
</ul>




<h2>Computational challenges</h2>
<p>
Due to their length, Oxford Nanopore reads have
unique value for <i>de novo</i>
assembly. However a successful approach needs
to deal with the high error rate.

<p>Traditional approaches to <i>de novo</i> assembly typically
rely on selecting a k-mer length that satisfies the following:

<ul>
<li>K-mers of the selected length are reasonably unique
in the target genome. For human assemblies, this typically means
k &#10886; 30.
<li>Most k-mers of the selected length are error free in the
target reads. This means that k must be significantly less
than the inverse of the error rate.
</ul>

<p>
For many sequencing technolgies the above conditions 
are satisfied for k around 30.
But for our target reads, with an error rate around 10%,
most 30-mers contains errors, and therefore 
assembly algorithms based on using such k-mers become unfeasible.

<p>
A possible approach consists of adding a preliminary error correction
step in which reads are aligned to each other and corrected based on consensus,
and then presenting to the assembler the corrected reads,
which hopefully have a much lower error rate. 
But such approaches tends to be slow, and in addition 
any errors made in the error correction step
are permanent and cannot be fixed during the assembly process.


<h2>Read representation in the Shasta assembler</h2>

<p> 
The computational techniques used in the Shasta assembler
rely on representing the sequence of input reads in a way
that the reduces the effect of errors on 
the <i>de novo</i> assembly process:
<ul>
<li>
The sequence of input reads is represented using 
<a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>.
<li>
In many assembly steps, the sequence of input reads is described
by using occurrences of a pre-determined subset of short k-mers
(k &#8776; 10 in run-encoding)
called <i>markers</i>.
</ul>

The next two sections expand on these two methods of
representing the input reads.


<h2>Run-length encoding of input reads</h2>

<p>
With <a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>,
the sequence of each input read is represented as a sequence of bases,
each with a repeat count that says how many times each of the bases is repeated. 
For example, the following read

<pre>
CGATTTAAGTTA
</pre>

is represented as follows using run-length encoding:

<pre>
CGATAGTA
11132121
</pre>


<p>
Using run-length encoding makes the assembly process
less sensitive to errors in the length of homopolymer runs,
which are the most common type of errors in Oxford Nanopore reads.
For example, consider these two reads:

<pre>
CGATTTAAGTTA
CGATTAAGGGTTA
</pre>

Using their raw representation above, these reads can aligned like this:

<pre>
CGATTTAAG--TTA
CGATT-AAGGGTTA
</pre>

Aligning the second read to the first required a deletion and two insertions.
But in run-length encoding, the two reads become:

<pre>
CGATAGTA
11132121
CGATAGTA
11122321
</pre>

The sequence portions are now identical and can be aligned trivially
and exactly, without any insertions or deletions:

<pre>
CGATAGTA
CGATAGTA
</pre>

The differences between the two reads only appear in the repeat counts:

<pre>
11132121
11122321
   * *
</pre>

<p>
The Shasta assembler uses one byte to represent repeat counts,
and as a result it only represents repeat counts
between 1 and 255. If a read contains more than 255
consecutive bases, it is discarded on input.
Such reads are extremely rare, and the occurrence of such a large
number of repeated bases is probably a symptom
that something is wrong with the read anyway.



<h5>Some properties of base sequences in run-length encoding</h5>
<ul>

<li>In the sequence portion of the run-length encoding,
consecutive bases always are always distinct. If they were not, the second one
would be removed from the run-length encoded sequence,
while increasing the repeat count for the first one.

<li>
With ordinary base sequences, the number of distinct k-mers of length k is 4<sup>k</sup>.
But run-length base sequences, the number of distinct k-mers of length k
is 4&#215;3<sup>k-1</sup>.
This is a consequence of the previous bullet.

<li>The run-length sequence is generally shorter than the raw sequence,
and cannot be longer. For a long random sequence, the number
of bases in the run-length representation is 3/4  of the number of bases
in the raw representation.

</ul>



<h2>Markers</h2>

<p>
Even with run-length encoding, error in input reads are still frequent.
To further reduce sensitivity to errors, and also to speed up
some of the computational steps in the assembly process,
the Shasta assembler also uses a read representation
based on <i>markers</i>. Markers are 
occurrences in reads of a pre-determined subset of short k-mers.
By default, Shasta uses for this purpose k-mers with k=10 in run-length
encoding, corresponding to an average approximately 13 bases
in raw read representation. 

<p>Just for the purposes of illustration, consider a description
using markers of length 3 in run-length encoding.
There is a total 4&times;3<sup>2</sup> = 36 distinct such markers. 
We arbitrarily choose the following fixed subset of the 36, and we assign an id 
to each of the kmers in the subset:

<table class="small-table">
<tr><td><code>TGC</code><td>0
<tr><td><code>GCA</code><td>1
<tr><td><code>GAC</code><td>2
<tr><td><code>CGC</code><td>3
</table>

<p>
Consider now the following portion of a read in run-length representation (here, the
repeat counts are irrelevant and so they are omitted):
<pre>
CGACACGTATGCGCACGCTGCGCTCTGCAGC
 GAC        GCA   TGC     GCA
                    CGC
</pre>
Occurrences of the k-mers defined in the table above are shown
and define the markers in this read. Note that markers
can overlap. Using the marker ids defined in the table above,
we can summarize the sequence of this read portion as follows:

<pre>
2 1 0 3 1
</pre>

This is the marker representation of the read portion above.
It just includes the sequence of markers occurring in the read,
not their positions.

<p>
Note that the marker representation loses information,
as it is not possible to reconstruct the complete initial sequence
from the marker representation. This also means that the 
marker representation is insensitive to errors in the sequence
portions that don't belong to any markers.

<p>
The Shasta assembler uses a random choice of the k-mers to be used
as markers. The length of the markers k is controlled by
assembly parameter <code>Kmers.k</code> with a default value of 10.
Each k-mer is randomly choosen to be used as a marker
with probability determined by assembly parameter 
<code>Kmers.probability</code> with a default value of 0.1.
With these default values, the total number of distinct
markers is approximately 0.1&times;4<sup>10</sup>&times;3<sup>9</sup>&#8776;7900.

<p>
The only constraint used in selecting k-mers to be used as markers
is that if a k-mer is a marker, its reverse
complement should also be a marker. This makes it easy to construct
the marker representation of the reverse complement
of a read from the
marker representation of the original read.
It also ensures strand symetry in some of the computational steps.

<p>
It is possible that the random selection of markers
is not optimal, and it may best to select the markers
based on their frequency in the input reads. 
This possibility has not yet been investigated.

<p>
Below is the run-length representation of a portion of a read
and its markers, as displayed by the Shasta http server.

<p>
<img class="fit-in-main" src=Markers.png>



<h2>Marker alignments</h2>


<h5>The marker representation is a sequence</h5>

The marker representation of a read is a sequence 
in an alphabet consisting of the marker ids.
This sequence is much shorter than the original sequence of the read,
but uses a much larger alphabet.
For example, 
with default Shasta assembly parameters, the marker representation
is 10 times shorter than the run-length encoded read sequence,
or about 13 times shorter than the raw read sequence.
Its alphabet has around 8000
symbols, many more than the 4 symbols that the original 
read sequence uses.  

<p>
Because the marker representation of a read is a sequence,
we can compute an alignment of two reads directly in
marker representation. Computing an alignment in this way
has two important advantages:
<ul>
<li>The shorter sequences and larger alphabet make
the alignment much faster to compute.
<li>The alignment is insensitive to read errors in
the portions that are not covered by any marker.
</ul>

These advantages are illustrated below using alignment 
matrices.


<h5>Alignment matrix</h5>
<p>
Consider two sequences on any alphabet, 
sequence x with n<sub>x</sub> symbols x<sub>i</sub> (i=0,...n<sub>x</sub>-1)
and 
sequence y with n<sub>y</sub> symbols y<sub>j</sub> (j=0,...n<sub>y</sub>-1).
The alignment matrix of the two sequences,
, A<sub>ij</sub>, is a n<sub>x</sub>&times;n<sub>y</sub>
matrix with elements
<p>
A<sub>ij</sub> = <span style='font-family:serif'>&delta;</span><sub>x<sub>i</sub>y<sub>j</sub></sub>
<p>
or, in words, A<sub>ij</sub> is 1 if x<sub>i</sub>=y<sub>j</sub>
and 0 otherwise.
(The Shasta assembler never explicitly constructs alignment matrices
except for display when requested interactively.
Alignment matrices are used here just for the purpose of illustration).
<p>
In portions where the sequences x and y are perfectly aligned,
the alignment matrix consists of a matrix diagonal set to 1.
Most of the remaining elements will be 0,
but many can be 1 just because the same symbol appears
at two unrelated locations in the two sequences.

<h5>Alignment matrix in raw base representation</h5>
<p>
The picture below shows a portion of a typical
alignment matrix of two reads in their representation
as a raw base sequence (not the run-length encoded representation),
with an optimal alignment shown in red and yellow.
(The Shasta assembler never performs such a computation, except
when requested interactively).

<p>
<img src=RawAlignment.png>

<p>
Here, elements of the alignment matrix that are 0 are displayed
in yellow or black/grey:
<ul>
<li>Yellow matrix elements are matrix element that are
0 but that were computed to be part of the optimal alignment 
(as mismatching alignment positions).
<li>Black or grey matrix elements are matrix element that are
0 and that were not computed to be part of the optimal alignment.
</ul>

Elements of the alignment matrix that are 1 are displayed
in red or green:
<ul>
<li>Red matrix elements are matrix element that are
1 and that were computed to be part of the optimal alignment 
(as matching alignment positions).
<li>Green matrix elements are matrix element that are
1 and that were not computed to be part of the optimal alignment.
</ul>
The grey lines are drawn 10 markers apart from each other
and their only purpose is to facilitate reading the picture -
the corresponding matrix elements are 0.

<p>
On average, about 25% of the matrix elements are 1, simply
because the alphabet has 4 symbols. 
Because of the large fraction of 1 elements and because of the high error rate,
it would be hard to visually locate the
optimal alignment in this picture, if it was not highlighted using colors:

<p>
<img src=RawAlignmentUnmarked.png>

<p>
Note that the alignment matrix contains frequent square
or rectangular blocks of 1 elements. They correspond to
homopolymer run. A square block indicates that the
two reads agree on the length of that homopolymer run,
and a non-square rectangular block indicates that the
two reads disagree. 
If we were using run-length encoding for this picture,
these blocks would all collapse to a single matrix element.



<h5>Alignment matrix in marker representation</h5>

<p>
For comparison, the picture below shows a portion of the alignment matrix
of two reads, in marker representation, as displayed by the Shasta
http server. 
Here, matrix elements that are 1 are displayed in green or red.
The ones in green are the ones that are part of the optimal alignment
computed by the Shasta assembler - see below for more information.
The grey lines are drawn 10 markers apart from each other
and their only purpose is to facilitate reading the picture -
the corresponding matrix elements are 0.
<b>Note that the colors in this picture are inconsistent
with those used in the illustration of the alignment
matrix in raw base representation above.</b>

<p>
<img id=MarkerAlignment src=MarkerAlignment.png>

<p>
Because of the much larger alphabet, matrix elements
that are 1 but are not part of the optimal alignment are infrequent.
In addition, each alignment matrix element here corresponds
on average to a 13&times;13 block in the alignment matrix in raw base sequence
shown above. The portion of alignment matrix in marker space
shown here covers about 120 markers or about 1500 bases
in the original representation of the read, compared to
only about
100 bases in the alignment matrix in raw representation shown above .


For these reasons, the marker representation
is orders of magnitude more efficient than the raw base 
representation when computing read
alignments.


<h5>Computing optimal alignments in marker representation</h5>
<p>
To compute the optimal alignment highlighted in green,
the Shasta assembler uses a simple alignment algorithm
on the marker representations of the two reads to be aligned.
It effectively costructs an optimal path in the alignment matrix,
but using some heuristics to speed up the computation:
<ul>
<li>The maximum number of markers that an alignment 
can skip on either read is limited to a maximum,
under control of assembly parameter <code>Align.maxSkip</code>
(default value 30 markers, corresponding to around 400
bases when all other Shasta parameters are at their default).
This reflects the fact that Oxford Nanopore reads can often
have long stretches in error.
In the alignment matrix shown above, the top left of the matrix has a skip of
about 20 markers (2 grey squares).
<li>The maximum number of markers that an alignment 
can skip at the beginning or end of a read is limited to a maximum,
under control of assembly parameter <code>Align.maxTrim</code>
(default value 30 markers, corresponding to around 400
bases when all other Shasta parameters are at their default).
This reflects the fact that Oxford Nanopore reads often
have an initial or final portion that is not usable.
<li>To avoid alignment artifacts,
marker k-mers that are too frequent in either of the two reads
being aligned are not used in the alignment computation.
For this purpose, the Shasta assembler uses a criterion based
on absolute number of occurrences of marker k-mers in the two reads,
altough a relative criterion (occurrences per Kb) may be more appropriate.
The current absolute frequency threshold is under control of assembly parameter
<code>Align.maxMarkerFrequency</code> (default 10 occurrences).


</ul>
Using these techniques and with the default
assembly parameters, the time to compute
an optimal alignment is &#8776;10<sup>-3</sup>-10<sup>-2</sup> seconds
in the Shasta implementation as of release 0.1.0 (April 2019).
A typical human assembly needs to compute &#8776;10<sup>8</sup> read
alignments which results in a total compute time &#8776;10<sup>-5</sup>-10<sup>-6</sup> seconds, or
&#8776;10<sup>-3</sup>-10<sup>-4</sup> seconds of elapsed time (&#8776; 1-3 hours) 
on a machine with 128 virtual processors.
This is one of the most computationally expensive portions of a Shasta assembly.
Some additional optimizations are possible in the code
that implement this computation,
and may be implemented in future releases.



<h3>Finding overlapping reads</h3>
<p>
Even though computing read alignments in marker representation is fast,
it still is not feasible to compute alignments among all possible pairs of reads.
For a human size genome with &#8776;10<sup>6</sup>-10<sup>7</sup> reads,
the number of pairs to consider would be &#8776;10<sup>12</sup>-10<sup>14</sup>,
and even at 10<sup>-3</sup> seconds per alignment the compute time
would be &#8776;10<sup>9</sup>-10<sup>11</sup> seconds,
or &#8776;10<sup>7</sup>-10<sup>9</sup> seconds elapsed time
(&#8776;10<sup>2</sup>-10<sup>4</sup> days) 
when using 128 virtual processors.

<p>
Therefore some means of narrowing down substantially the number
of pairs to be considered is essential.
The Shasta assembler uses for this purpose a slightly modified MinHash
scheme based on the marker representation of reads.
<p>
For a general description of the MinHash algorithm
see the 
<a href='https://en.wikipedia.org/wiki/MinHash'>Wikipedia article</a>
or this 
<a href='http://infolab.stanford.edu/~ullman/mmds/ch3.pdf'>excellent book chapter</a>.
In summary, the MinHash algorithm takes as input a set of items
each characterized by a set of features. Its goal is to find
pairs of the input items that have a high 
<a href='https://en.wikipedia.org/wiki/Jaccard_index'>Jaccard similarity index</a> -
that is, pairs of items that have many features in common. 
The algorithm proceeds by iterations. At each iteration, a
new hash table is created and a
hash function that operates on the feature set is selected.
For each item, the hash function of each of its features is evaluated,
and the minimum hash function value found is used to 
select the hash table bucket that each item is stored in.
It can be proven that the probability of two items ending up
in the same bucket equals the Jacard similarity index of the two
items - that is, items in the same bucket are more likely 
to be highly similar than items in different buckets.
The algorithm then adds to the pairs of potentially similar
items all pairs of items that are in the same bucket.

<p>
When all iterations are complete, the probability that a pair
of items was found at least once is an increasing function
of the Jaccard similarity of the two items. 
In other words, the pairs found are enriched for pairs
that have high similarity. One can now consider all the pairs found
(hopefully a much smaller set than all possible pairs)
and compute the Jaccard similarity index for each,
then keep only the pairs for which the index is sufficiently high.
The algorithm does not guarantee that all pairs 
with high similarity will be found - only that the probability
of finding all pairs is an increasing function of their similarity.

<p>
The algorithm is used by Shasta with items being oriented reads
(a read in either original or reverse complemented orientation)
and features being consecutive occurrences of m markers in the
marker representation of the oriented read. 
For example, consider an oriented read with the following marker representation: 

<pre>
18,45,71,3,15,6,21
</pre>

If m is selected equal to 4 (the Shasta default, controlled 
by assembly parameter <code>MinHash.m</code>),
the oriented read is assigned the following features:

<pre>
(18,45,71,3)
(45,71,3,15)
(71,3,15,6)
(3,15,6,21)
</pre>

<p>
From the 
<a href='#MarkerAlignment'>picture above</a> of an alignment matrix in
marker representation, we see that streaks of 4 or more common consecutive
markers are relatively common. We have to keep in mind that,
with Shasta default parameters, 4 consecutive markers 
span an average 40 bases in run-length encoding or about 52 bases
in the original raw base representation.
At a typical error rate around 10%, such a portion of a read would
contain on average 5 errors. Yet, the marker representation
in run-length space
is sufficiently robust that these common "features"
are relatively common despite the high error rate.
This indicates that we can expect the
MinHash algorith to be effective in finding pairs of overlapping reads.

<p>
However, the MinHash algorithm has a feature that is undesirable
for our purposes: namely, that the algorithm is good at finding 
read pairs with high Jaccard similarity index.
For two sets X and Y, the Jaccard similarity index is defined as the ratio

<pre>
J = |X&#8745;Y| / |X&#8746;Y|
</pre>

Because the read length distribution of Oxford Nanopore reads
is very wide, it is very common to have pairs of reads with 
very different lengths. Consider now two reads with lengths n<sub>x</sub> and n<sub>y</sub>, with 
n<sub>x</sub>&lt;n<sub>y</sub>, that overlap exactly over the entire length n<sub>x</sub>.
The Jaccard similarity is in this case given by n<sub>x</sub>/n<sub>y</sub> &lt; 1.
This means that, if one of the reads in a pair is much shorter than
the other one, their Jaccard similarity will be low even in 
the best case of exact overlap. As a result, the
unmodified MinHash algorithm will not do a good job
at finding overlapping pairs of reads with very different length.

<p>
For this reason, the Shasta assembler uses a small modification to
the MinHash algorithm: instead of just using the minimum hash 
for each oriented read for each iteration,
it keeps all hashes below a given threshold. Each oriented read
can be stored in multiple buckets, one for each low hash encountered.
This has the effect of eliminating the bias against 
pairs in which one read is much shorter than the other.
The modified algorithm is referred to as <i>LowHash</i>
in the Shasta source code.
It is effectively equivalent to a an indexing approach
in which we index all features with low hash.

<p>
The LowHash algorithm is controlled by the following 
assembly parameters:

<ul>
<li><code>MinHash.m</code> (default 4):
the number of consecutive markers that define a feature.
<li><code>MinHash.hashFraction</code> (default 0.01):
The fraction of hash values that count as "low".
<li><code>MinHash.minHashIterationCount</code> (default 10):
The number of iterations.
<li><code>MinHash.maxBucketSize</code> (default 10):
The maximum number of items for a bucket to be considered.
Buckets with more than this number of items are ignored.
The goal of this parameter is to mitigate
the effect of common repeats, which 
can result in buckets containing large numbers of
unrelated oriented reads.
<li><code>MinHash.minFrequency</code> (default 2):
the number of times a pair of oriented reads has to be found to be considered 
and stored as a possible pair of overlapping reads.
</ul>


<h5>Initial assembly steps</h5>
<p>
Initial steps of a Shasta assembly proceed as follows.
If the assembly is setup for best performance
(<code>--memoryMode filesystem --memoryBacking 2M</code>
if using the Shasta executable), all data structures
are stored in memory, and no disk activity takes
place except for initial loading of the input reads,
storing of assembly results, and storing a small number
of small files with useful summary information.

<ul>
<li>Input reads are read from Fasta files and converted
to run-length representation.
<li>K-mers to be used as markers are randomly selected.
<li>Occurrences of those marker k-mers in all oriented reads are found.
<li>The LowHash algorithm finds candidate pairs of overlapping oriented reads.
<li>A marker alignment is computed for each candidate pair of oriented reads.
If the marker alignment contains a minimum number of aligned markers,
the pair is stored as an aligned pair. The minimum number
of aligned markers is controlled by assembly parameter
<code>Align.minAlignedMarkerCount</code>.
</ul>



<h3>Read graph</h3>
<p>
Using the methods covered so far, an assembly has created
a list of pairs of oriented reads, each pair having a plausible marker
alignment. 
How to use this type of information for assembly is a classical problem
with a standard solution
<a href='https://doi.org/10.1093/bioinformatics/bti1114'>(Myers, 2005)</a>,
the <i>string graph</i>.

<p>
However, the prescriptions in the Myers paper cannot be directly used here,
the main reason being that the process used to find pairs
of overlapping reads is probabilistic and does not guarantee
that all overlapping pairs will be found. 
Direct application of the Myers approach in this context results
in unnecessary breakages in continuity.

<p>
The approach currently used in the Shasta assembler is very simple, perhaps simplistic,
and does not extract all the available information. 
As a result, contiguity of assembled sequence is not 
the best that can be achieved from the data. 
Improvements are certainly possible here
and will hopefully be made in future releases.
Despite this shortcoming, the current
implementation is still a useful tool for <i>de novo</i>
assembly of Oxford Nanopore reads.

<p>
In the current simple approach, the Shasta assembler creates
un undirected graph, the <i>Read Graph</i>, in which
each vertex represents an oriented read
(that is, a read in either original orientation or reverse
complemented), and an undirected edge
between two vertices is created if we have found an alignment
between the corresponding oriented reads.

<p>
However, the read graph as constructed in this way suffers
from high connectivity in repeat regions.
Therefore, the Shasta assembler only keeps a
k-Nearest-Neighbor subset of the edges.
That is, for each vertex (oriented read)
we only keep the k edges with the best alignments
(greatest number of aligned markers). 
The number of edges kept
for each vertex is controlled by assembly parameter
<code>ReadGraph.maxAlignmentCount</code>,
with a default value of 6.
Note that, despite the k-Nearest-Neighbor subset,
it remains possible for a vertex to have degree
more than k.

<p>
Note that each read contributes two vertice to the read graph,
one in its original orientation, and one in reverse
complemented orientation. 
Therefore the read graph contains two strands,
each strand at full coverage. 
This makes it easy to investigate and potentially detect
erroneous strand jumps that would be much less obvious
if using approaches using one vertex per read.

<p>
An example of a portion of the read graph, as displayed
by the Shasta http server, is shown here.

<img class="fit-in-main" src=ReadGraph1.png>

<p>
Even though the graph is undirected, edges that
correspond to overlap alignments are drawn with an arrow
that points from the leftmost oriented read to the 
rightmost one. 
Edges that correspond to containment alignments
are drawn in red and without an arrow.
Vertices are drawn with area proportional to the length of
the corresponding reads.

<p>
The linear structure of the read graph successfully reflects 
the linear arrangement of the input reads
and their origin on the genome being assembled. 

<p>
However, deviations from the linear structure can
occur in the presence of long repeats,
typically for high similarity segment duplications:

<img class="fit-in-main" src=ReadGraph2.png>

<p>
The current Shasta implementation does not attempt
to remove the obviously incorrect connections.
This results in unnecessary breaks in assembly contiguity.
Despite this, Shasta assembly contiguity is  adequate
and comparable to what other, less performant long read assemblers achieve.
It is hoped that future Shasta releases will do a better
job at handling these situations.


<h3>Marker graph</h3>
<p>
Consider a read whose marker representation is: 
<pre>
a b c d e
</pre>
We can represent this read as a directed graph
that the describes the sequence in which its markers appear:
<p>
<img src="MarkerGraph-1.dot.png">
<p>
This is not very useful but illustrates
the simplest form of a <i>marker graph</i>
as used in the Shasta assembler.
The marker graph is a directed graph
in which each vertex represents a marker
and each edge represents the transition
between consecutive markers.
We can associate sequence with each vertex and edge of the
marker graph:
<ul>
<li>Each vertex is associated with the sequence of the corrersponding 
marker.
<li>If the markers of the source and target vertex of an edge
do not overlap, the edge is associated with the sequence
intervening between the two markers.
<li>If the markers of the source and target vertex of an edge
do overlap, the edge is associated with the overlapping portion
of the marker sequences.
</ul>

<p>
Consider now a second read with the following marker
representation, which differs from the previous one
just by replacing marker <code>c</code> with <code>x</code>:

<pre>
a b x d e
</pre>

<p>
The marker graph for the two reads is:
<p>
<img src="MarkerGraph-2.dot.png">

<p>
In the optimal alignment of the two reads, markers 
<code>a, b, d, e</code> are aligned. We can redraw the marker graph
grouping together vertices that correspond to aligned markers:

<p>
<img src="MarkerGraph-3.dot.png">

<p>
Finally, we can merge aligned vertices to obtain
a marker graph describing the two aligned reads:

<p>
<img src="MarkerGraph-4.dot.png">

<p>
Here, by construction each vertex still has a unique
sequence associated with it - the common sequence
of the markers that were merged
(however the corresponding repeat counts
can be different for each contributing read).
An edge, on the other hand, can have different sequences
associated with it, one corresponding to each
of the contributing reads. 
In this example, edges <code>a->b</code>
and <code>d->e</code> have two contributing reads,
which can each have distinct sequence between 
the two markers.

<p>
We call coverage of a vertex or edge the number of reads "contributing"
to it. In this example, vertices <code>a, b, d, e</code> have coverage 2
and vertices <code>c, x</code> have coverage 1.
Edges <code>a->b</code>
and <code>d->e</code> have coverage 2, and the remaining edges have coverage 1.

<p>
The construction of the marker graph was illustrated above 
for two reads, but the Shasta assembler
construct a global marker graph which takes into account
all oriented reads:

<ul>
<li>The process starts with a distinct vertex for each marker of each
oriented read. Note that at this stage the marker graph
is large (&#8776; 2&times;10<sup>10</sup> vertices for a human assembly
using default assembly parameters).
<li>For each marker alignment
corresponding to an edge of the read graph,
we merge vertices corresponding to aligned markers.
<li>Of the resulting merged vertices, we remove those whose 
coverage in too low or two high, indicating that the contributing
reads or some of the alignments involved are probably in error.
This is controlled by assembly parameters
<code>MarkerGraph.minCoverage</code> (default 10)
and <code>MarkerGraph.maxCoverage</code> (default 100),
which specify the minimum and maximum coverage
for a vertex to be kept.
<li>Edges are created. An edge <code>v0->v1</code> is created if
there is at least a read contributing to both <code>v0</code> and <code>v1</code>
and for which all markers intervening
between <code>v0</code> and <code>v1</code>
belong to vertices that were removed.
</ul>

Note that this does not mean that all vertices 
with the same marker sequence are merged -
two vertices are only merged if they have
the same marker sequence, and if there are
at least two reads for which the corresponding markers are aligned.

<p>
Given the large number of initial vertices involved, 
this computation is not trivial. 
To allow 
efficient computation in parallel on many threads, a 
<a href='https://github.com/wjakob/dset'>lock-free implementation</a> 
of the 
<a href='https://en.wikipedia.org/wiki/Disjoint-set_data_structure'>
disjoint data set data structure</a>, 
as first described by 
<a href='http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.56.8354&rep=rep1&type=pdf'>
Anderson and Woll (1994)</a>,
is used
for merging vertices.
Some code changes 
<a href='Acknowledgments.html#Dset'>were necessary</a> 
to permit large numbers of vertices,
as the initial implementation by Wenzel Jakob only allowed
for 32-bit vertex ids.



<br><br><hr>
<b>This page is work in progress...</b>

</main>


</body>
</html>


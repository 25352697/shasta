<!DOCTYPE html>
<html>

<head>
<link rel=stylesheet href=style.css />
<link rel=icon href=CZI-new-logo.png />
</head>

<body>
    <nav role="navigation">
        <ul>
            <a class="main-nav" href=index.html><li >Shasta</li></a>
                <a href=QuickStart.html><li>Quick Start</li></a>
                
                <li aria-haspopup="true"> How to
                <ul class="dropdown" aria-label="submenu">
                <a href=Running.html><li>Run an assembly</li></a>
                <a href=Performance.html><li>Maximize assembly performance</li></a>
                <a href=BuildingFromSource.html><li>Build the code from source</li></a>
                <a href=InspectingResults.html><li>Inspect or debug assembly results</li></a>
                <a href=Contributing.html><li>Contribute to Shasta</li></a>
                <a href=ReportingBugs.html><li>Report problems or ask questions</li></a>
                </ul>
            </li>
            <li aria-haspopup="true"> About
                    <ul class="dropdown" aria-label="submenu">
                            <a href=Motivation.html><li>Motivation</li></a>
                            <a href=CurrentStatus.html><li>Current status</li></a>
                            <a href=SupportedPlatforms.html><li>Supported platforms</li></a>
                            <a href=Acknowledgments.html><li>Acknowledgments</li></a>
                            <a href=ComputationalMethods.html><li>Computational methods</li></a>
                            <a href=Compatibility.html><li>Compatibility across releases</li></a>
    
                    </ul>
                </li>
    
        </ul>
    </nav>
    <main>
    
    
    
<h1>Computational methods</h1>

<h2>Oxford Nanopore reads</h2>

<p>
The Shasta assembler is being developed with the goal of assembling 
<a href="https://nanoporetech.com">Oxford Nanopore</a> reads,
although it can also be used to assemble other types of long reads
such as those generated by <a href="https://www.pacb.com/">Pacific Biosciences</a>
sequencing platforms.

<p>
Oxford Nanopore reads are rapidly evolving in characteristics, 
and the Shasta assembler was developed targeting reads obtained
using the sequencing protocols in used in the nanopore group at
University of California at Santa Cruz in early 2019.
These reads can be characterized as follows:

<ul>
<li>Typical length around 50 Kb, with just a few percent of coverage
in reads below 10 Kb and 10% or more of coverage in reads longer than 100 Kb.
<li>High error rate of raw reads, with sequence identity around 90%
or, equivalently, a raw read error rate around 10%.
<li>The dominant error mode consists of errors in the length of homopolymer runs
at all lengths. Errors in short homopolymer runs (lengths 1-5)
are particularly deleterious due to the high frequency 
of such runs.
</ul>




<h2>Computational challenges</h2>
<p>
Due to their length, Oxford Nanopore reads have
unique value for <i>de novo</i>
assembly. However a successful approach needs
to deal with the high error rate.

<p>Traditional approaches to <i>de novo</i> assembly typically
rely on selecting a k-mer length that satisfies the following:

<ul>
<li>K-mers of the selected length are reasonably unique
in the target genome. For human assemblies, this typically means
k &#10886; 30.
<li>Most k-mers of the selected length are error free in the
target reads. This means that k must be significantly less
than the inverse of the error rate.
</ul>

<p>
For many sequencing technolgies the above conditions 
are satisfied for k around 30.
But for our target reads, with an error rate around 10%,
most 30-mers contains errors, and therefore 
assembly algorithms based on using such k-mers become unfeasible.

<p>
A possible approach consists of adding a preliminary error correction
step in which reads are aligned to each other and corrected based on consensus,
and then presenting to the assembler the corrected reads,
which hopefully have a much lower error rate. 
But such approaches tends to be slow, and in addition 
any errors made in the error correction step
are permanent and cannot be fixed during the assembly process.


<h2>Read representation in the Shasta assembler</h2>

<p> 
The computational techniques used in the Shasta assembler
rely on representing the sequence of input reads in a way
that the reduces the effect of errors on 
the <i>de novo</i> assembly process:
<ul>
<li>
The sequence of input reads is represented using 
<a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>.
<li>
In many assembly steps, the sequence of input reads is described
by using occurrences of a pre-determined subset of short k-mers
(k &#8776; 10 in run-encoding)
called <i>markers</i>.
</ul>

The next two sections expand on these two methods of
representing the input reads.


<h2>Run-length encoding of input reads</h2>

<p>
With <a href='https://en.wikipedia.org/wiki/Run-length_encoding'>run-length encoding</a>,
the sequence of each input read is represented as a sequence of bases,
each with a repeat count that says how many times each of the bases is repeated. 
For example, the following read

<pre>
CGATTTAAGTTA
</pre>

is represented as follows using run-length encoding:

<pre>
CGATAGTA
11132121
</pre>


<p>
Using run-length encoding makes the assembly process
less sensitive to errors in the length of homopolymer runs,
which are the most common type of errors in Oxford Nanopore reads.
For example, consider these two reads:

<pre>
CGATTTAAGTTA
CGATTAAGGGTTA
</pre>

Using their raw representation above, these reads can aligned like this:

<pre>
CGATTTAAG--TTA
CGATT-AAGGGTTA
</pre>

Aligning the second read to the first required a deletion and two insertions.
But in run-length encoding, the two reads become:

<pre>
CGATAGTA
11132121
CGATAGTA
11122321
</pre>

The sequence portions are now identical and can be aligned trivially
and exactly, without any insertions or deletions:

<pre>
CGATAGTA
CGATAGTA
</pre>

The differences between the two reads only appear in the repeat counts:

<pre>
11132121
11122321
   * *
</pre>

<p>
The Shasta assembler uses one byte to represent repeat counts,
and as a result it only represents repeat counts
between 1 and 255. If a read contains more than 255
consecutive bases, it is discarded on input.
Such reads are extremely rare, and the occurrence of such a large
number of repeated bases is probably a symptom
that something is wrong with the read anyway.



<h5>Some properties of base sequences in run-length encoding</h5>
<ul>

<li>In the sequence portion of the run-length encoding,
consecutive bases always are always distinct. If they were not, the second one
would be removed from the run-length encoded sequence,
while increasing the repeat count for the first one.

<li>
With ordinary base sequences, the number of distinct k-mers of length k is 4<sup>k</sup>.
But run-length base sequences, the number of distinct k-mers of length k
is 4&#215;3<sup>k-1</sup>.
This is a consequence of the previous bullet.

<li>The run-length sequence is generally shorter than the raw sequence,
and cannot be longer. For a long random sequence, the number
of bases in the run-length representation is 3/4  of the number of bases
in the raw representation.

</ul>



<h2>Markers</h2>

<p>
Even with run-length encoding, error in input reads are still frequent.
To further reduce sensitivity to errors, and also to speed up
some of the computational steps in the assembly process,
the Shasta assembler also uses a read representation
based on <i>markers</i>. Markers are 
occurrences in reads of a pre-determined subset of short k-mers.
By default, Shasta uses for this purpose k-mers with k=10 in run-length
encoding, corresponding to an average approximately 13 bases
in raw read representation. 

<p>Just for the purposes of illustration, consider a description
using markers of length 3 in run-length encoding.
There is a total 4&times;3<sup>2</sup> = 36 distinct such markers. 
We arbitrarily choose the following fixed subset of the 36, and we assign an id 
to each of the kmers in the subset:

<table class="small-table">
<tr><td><code>TGC</code><td>0
<tr><td><code>GCA</code><td>1
<tr><td><code>GAC</code><td>2
<tr><td><code>CGC</code><td>3
</table>

<p>
Consider now the following portion of a read in run-length representation (here, the
repeat counts are irrelevant and so they are omitted):
<pre>
CGACACGTATGCGCACGCTGCGCTCTGCAGC
 GAC        GCA   TGC     GCA
                    CGC
</pre>
Occurrences of the k-mers defined in the table above are shown
and define the markers in this read. Note that markers
can overlap. Using the marker ids defined in the table above,
we can summarize the sequence of this read portion as follows:

<pre>
2 1 0 3 1
</pre>

This is the marker representation of the read portion above.
It just includes the sequence of markers occurring in the read,
not their positions.

<p>
Note that the marker representation loses information,
as it is not possible to reconstruct the complete initial sequence
from the marker representation. This also means that the 
marker representation is insensitive to errors in the sequence
portions that don't belong to any markers.

<p>
The Shasta assembler uses a random choice of the k-mers to be used
as markers. The length of the markers k is controlled by
assembly parameter <code>Kmers.k</code> with a default value of 10.
Each k-mer is randomly choosen to be used as a marker
with probability determined by assembly parameter 
<code>Kmers.probability</code> with a default value of 0.1.
With these default values, the total number of distinct
markers is approximately 0.1&times;4<sup>10</sup>&times;3<sup>9</sup>&#8776;7900.

<p>
The only constraint used in selecting k-mers to be used as markers
is that if a k-mer is a marker, its reverse
complement should also be a marker. This makes it easy to construct
the marker representation of the reverse complement
of a read from the
marker representation of the original read.
It also ensures strand symetry in some of the computational steps.

<p>
It is possible that the random selection of markers
is not optimal, and it may best to select the markers
based on their frequency in the input reads. 
This possibility has not yet been investigated.

<p>
Below is the run-length representation of a portion of a read
and its markers, as displayed by the Shasta http server.

<p>
<img class="fit-in-main" src=Markers.png>



<h2>Marker alignments</h2>


<h5>The marker representation is a sequence</h5>

The marker representation of a read is a sequence 
in an alphabet consisting of the marker ids.
This sequence is much shorter than the original sequence of the read,
but uses a much larger alphabet.
For example, 
with default Shasta assembly parameters, the marker representation
is 10 times shorter than the run-length encoded read sequence,
or about 13 times shorter than the raw read sequence.
Its alphabet has around 8000
symbols, many more than the 4 symbols that the original 
read sequence uses.  

<p>
Because the marker representation of a read is a sequence,
we can compute an alignment of two reads directly in
marker representation. Computing an alignment in this way
has two important advantages:
<ul>
<li>The shorter sequences and larger alphabet make
the alignment much faster to compute.
<li>The alignment is insensitive to read errors in
the portions that are not covered by any marker.
</ul>

These advantages are illustrated below using alignment 
matrices.


<h5>Alignment matrix</h5>
<p>
Consider two sequences on any alphabet, 
sequence x with n<sub>x</sub> symbols x<sub>i</sub> (i=0,...n<sub>x</sub>-1)
and 
sequence y with n<sub>y</sub> symbols y<sub>j</sub> (j=0,...n<sub>y</sub>-1).
The alignment matrix of the two sequences,
, A<sub>ij</sub>, is a n<sub>x</sub>&times;n<sub>y</sub>
matrix with elements
<p>
A<sub>ij</sub> = <span style='font-family:serif'>&delta;</span><sub>x<sub>i</sub>y<sub>j</sub></sub>
<p>
or, in words, A<sub>ij</sub> is 1 if x<sub>i</sub>=y<sub>j</sub>
and 0 otherwise.
(The Shasta assembler never explicitly constructs alignment matrices
except for display when requested interactively.
Alignment matrices are used here just for the purpose of illustration).
<p>
In portions where the sequences x and y are perfectly aligned,
the alignment matrix consists of a matrix diagonal set to 1.
Most of the remaining elements will be 0,
but many can be 1 just because the same symbol appears
at two unrelated locations in the two sequences.

<h5>Alignment matrix in raw base representation</h5>
<p>
The picture below shows a portion of a typical
alignment matrix of two reads in their representation
as a raw base sequence (not the run-length encoded representation),
with an optimal alignment shown in red and yellow.
(The Shasta assembler never performs such a computation, except
when requested interactively).

<p>
<img src=RawAlignment.png>

<p>
Here, elements of the alignment matrix that are 0 are displayed
in yellow or black/grey:
<ul>
<li>Yellow matrix elements are matrix element that are
0 but that were computed to be part of the optimal alignment 
(as mismatching alignment positions).
<li>Black or grey matrix elements are matrix element that are
0 and that were not computed to be part of the optimal alignment.
</ul>

Elements of the alignment matrix that are 1 are displayed
in red or green:
<ul>
<li>Red matrix elements are matrix element that are
1 and that were computed to be part of the optimal alignment 
(as matching alignment positions).
<li>Green matrix elements are matrix element that are
1 and that were not computed to be part of the optimal alignment.
</ul>
The grey lines are drawn 10 markers apart from each other
and their only purpose is to facilitate reading the picture -
the corresponding matrix elements are 0.

<p>
On average, about 25% of the matrix elements are 1, simply
because the alphabet has 4 symbols. 
because of the large fraction f 1 elements,
it would be hard to visually locate the
optimal alignment in this picture, if it was not highlighted using colors.

<p>
Noe that the alignment matrix contains frequent square
or rectangular blocks of 1 elements. They correspond to
homopolymer run. A square block indicates that the
two reads agree on the length of that homopolymer run,
and a non-square rectangular block indicates that the
two reads disagree. 
If we were using run-length encoding for this picture,
these blocks would all collapse to a single matrix element.



<h5>Alignment matrix in marker representation</h5>

<p>
For comparison, the picture below shows a portion of the alignment matrix
of two reads, in marker representation, as displayed by the Shasta
http server. 
Here, matrix elements that are 1 are displayed in green or red.
The ones in green are the ones that are part of the optimal alignment
computed by the Shasta assembler - see below for more information.
The grey lines are drawn 10 markers apart from each other
and their only purpose is to facilitate reading the picture -
the corresponding matrix elements are 0.

<p>
<img src=MarkerAlignment.png>

<p>
Because of the much larger alphabet, matrix elements
that are 1 but are not part of the optimal alignment are rare.
In addition, each alignment matrix element here corresponds
on average to a 13&times;13 block in the alignment matrix in raw base sequence
shown above. For these reasons, the marker representation
is orders of magnitude more efficient than the raw base 
representation when computing read
alignments.


<h5>Computing optimal alignments in marker representation</h5>
<p>
To compute the optimal alignment highlighted in green,
the Shasta assembler uses a simple alignment algorithm
on the marker representations of the two reads to be aligned.
It effectively costructs an optimal path in the alignment matrix,
but using some heuristics to speed up the computation:
<ul>
<li>The maximum number of markers that an alignment 
can skip on either read is limited to a maximum,
under control of assembly parameter <code>Align.maxSkip</code>
(default value 30 markers, corresponding to around 400
bases when all other Shasta parameters are at their default).
This reflects the fact that Oxford Nanopore reads can often
have long stretches in error.
In the alignment matrix shown above, the top left of the matrix has a skip of
about 20 markers (2 grey squares).
<li>The maximum number of markers that an alignment 
can skip at the beginning or end of a read is limited to a maximum,
under control of assembly parameter <code>Align.maxTrim</code>
(default value 30 markers, corresponding to around 400
bases when all other Shasta parameters are at their default).
This reflects the fact that Oxford Nanopore reads often
have an initial or final portion that is not usable.
<li>To avoid alignment artifacts,
marker k-mers that are too frequent in either of the two reads
being aligned are not used in the alignment computation.
For this purpose, the Shasta assembler uses a criterion based
on absolute number of occurrences of marker k-mers in the two reads,
altough a relative criterion (occurrences per Kb) may be more appropriate.
The current absolute frequency threshold is under control of assembly parameter
<code>Align.maxMarkerFrequency</code> (default 10 occurrences).


</ul>
Using these techniques and with the default
assembly parameters, the time to compute
an optimal alignment is &#8776;10<sup>-3</sup>-10<sup>-2</sup> seconds
in the Shasta implementation as of release 0.1.0 (April 2019).
A typical human assembly needs to compute &#8776;10<sup>8</sup> read
alignments which results in a total compute time &#8776;10<sup>-5</sup>-10<sup>-6</sup> seconds, or
&#8776;10<sup>-3</sup>-range 10<sup>-4</sup> seconds of elapsed time (&#8776; 1-3 hours) 
on a machine with 128 virtual processors.
This is one of the most computationally expensive portions of a Shasta assembly.
Some additional optimizations are possible in the code
that implement this computation,
and may be implemented in future releases.



<br><br><hr>
<b>This page is work in progress...</b>




</main>


</body>
</html>


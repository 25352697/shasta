#include "TrainedBayesianConsensusCaller.hpp"
#include "Coverage.hpp"
using namespace ChanZuckerberg;
using namespace shasta;


static const string trainedDistributionFilepath = "consensus_distribution";

// The constructor does not have any parameters.
// All data should be read from a file with fixed name
// in the run directory. We will update the documentation accordingly.
TrainedBayesianConsensusCaller::TrainedBayesianConsensusCaller()
{
    ifstream trainedDistributionFile(trainedDistributionFilepath);
    
    std::string line;
    
    // Load the header line and ignore it
    std::getline(trainedDistributionFile, line);
    
    std::map<std::tuple<AlignedBase, size_t, AlignedBase, size_t>, double> distribution;
    
    while (std::getline(trainedDistributionFile, line)) {
        // Parse each line of the .tsv file generated by the training script
        
        // Strip the newline character
        line.erase(std::remove(line.begin(), line.end(), '\n'), line.end())
        
        // Tokenize the line by tabs
        stringstream strm(line)
        vector<string> tokens;
        string token;
        while (std::getline(strm, token, '\t')) {
            tokens.push_back(token);
        }
        
        // Make sure the data received matches the expected format
        assert(tokens.size() == 5);
        assert(tokens[0].size() == 1);
        assert(tokens[2].size() == 1);
        
        // Parse tokens
        AlignedBase calledBase = AlignedBase::fromCharacter(tokens[0].front());
        size_t calledRepeatCount = std::stoull(tokens[1]);
        AlignedBase trueBase = AlignedBase::fromCharacter(tokens[2].front());
        size_t trueRepeatCount = std::stoull(tokens[3]);
        double probability = std::stod(tokens[4]);
        
        maxRepeatCount = std::max(std::max(calledRepeatCount, trueRepeatCount), maxRepeatCount);
        
        distribution[make_tuple(calledBase, calledRepeatCount, trueBase, trueRepeatCount)] = probability;
    }
    
    // Make vector of all possible homopolymer repeats
    repeatBases.reserve(4 * maxRepeatCount + 1);
    repeatBases.emplace_back(AlignedBase::fromCharacter('-'), 0);
    for (char base : "ACGT") {
        for (size_t len = 1; len <= maxRepeatCount; len++) {
            repeatBases.emplace_back(AlignedBase::fromCharacter(base), len);
        }
    }
    
    // Compute the conditional probability of each true run length base given each called run length base
    for (const auto& calledRepeatBase : repeatBases) {
        
        double normalizingFactor = 0.0;
        for (const auto& trueRepeatBase : repeatBases) {
            normalizingFactor += distribution[std::make_tuple(calledRepeatBase.base,
                                                              calledRepeatBase.repeatCount,
                                                              trueRepeatBase.base,
                                                              trueRepeatBase.repeatCount)];
        }
        double logNormalizingFactor = log(normalizingFactor);
        
        for (const auto& trueRunLengthBase : runLengthBases) {
            auto key = std::make_tuple(calledRepeatBase.first, calledRepeatBase.second,
                                       trueRepeatBase.first, trueRepeatBase.second);
            logConditionalProbabilities[key] = log(distribution[key]) - logNormalizingFactor;
        }
    }
}



Consensus TrainedBayesianConsensusCaller::operator()(
    const Coverage& coverage) const
{

    // Initialize the return value
    double maxLogLikelihood = std::numeric_limits<double>::lowest();
    Consensus consensus;
    
    // Check likelihood for each possible consensus call
    for (const Consensus& trueRepeatBase : repeatBases) {
        double logLikelihood = 0.0;
        for (const ConsensusData& observation : coverage.getReadCoverageData()) {
            // Match either the bases or their complements depending on which one was the actual
            // called read sequence (i.e. the base that traversed the nanopore)
            AlignedBase trueLookupBase, calledLookupBase;
            if (observation.strand) {
                trueLookupBase = trueRunLengthBase.base.complement();
                calledLookupBase = observation.base.complement();
            }
            else {
                trueLookupBase = trueRunLengthBase.base;
                calledLookupBase = observation.base;
            }
            
            logLikelihood += logConditionalProbabilities.at(std::make_tuple(calledLookupBase,
                                                                            observation.repeatCount,
                                                                            trueLookupBase,
                                                                            trueRepeatBase.repeatCount));
        }
        
        // Identify the maximum likelihood consensus
        if (logLikelihood > maxLogLikelihood) {
            maxLogLikelihood = logLikelihood;
            consensus = trueRepeatBase
        }
    }
    
    return consensus;
}

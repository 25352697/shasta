// Alternative alignment function with 2 suffix (Edlib).

// Shasta.
#include "Assembler.hpp"
using namespace shasta;

// Suppress some warning messages generated by Edlib.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

// Edlib.
#include "edlib.hpp"
using namespace edlib;




void Assembler::alignOrientedReads2(
    OrientedReadId orientedReadId0,
    OrientedReadId orientedReadId1,
    Alignment& alignment,
    AlignmentInfo& alignmentInfo)
{
    // Gather the KmerId's of orientedRead0.
    const span<CompressedMarker> markers0 =
        markers[orientedReadId0.getValue()];
    vector<KmerId> kmerIds0;
    kmerIds0.reserve(markers0.size());
    for(const CompressedMarker marker: markers0) {
        kmerIds0.push_back(marker.kmerId);
        // cout << "kmerIds0: " << marker.kmerId << endl;
    }

    // Gather the KmerId's of orientedRead1.
    const span<CompressedMarker> markers1 =
        markers[orientedReadId1.getValue()];
    vector<KmerId> kmerIds1;
    kmerIds1.reserve(markers1.size());
    for(const CompressedMarker marker: markers1) {
        kmerIds1.push_back(marker.kmerId);
        // cout << "kmerIds1: " << marker.kmerId << endl;
    }

    cout << "Number of markers " << kmerIds0.size() << " " << kmerIds1.size() << endl;

    // Edlib alignment options.
    EdlibAlignConfig config;
    config.k = -1;
    config.mode = EDLIB_MODE_HW;
    config.task = EDLIB_TASK_PATH;
    config.additionalEqualities = 0;
    config.additionalEqualitiesLength = 0;

    // THIS NEEDS WORK *******************************

    // Call Edlib to compute the alignment.
    const EdlibAlignResult result = edlibAlign<KmerId, KmerId>(
        kmerIds0.data(), kmerIds0.size(),
        kmerIds1.data(), kmerIds1.size(),
        config);
    if(result.status != EDLIB_STATUS_OK) {
        throw runtime_error("Error during edlibAlign.");
    }

    // For debugging, write to cout.
    cout << "Edit distance " << result.editDistance << endl;
    cout << "Alignment length " << endl;
    cout << "Start/end locations:" << endl;
    for(int i=0; i<result.numLocations; i++) {
        cout << result.startLocations[i] << " " << result.endLocations[i] << endl;
    }
#if 0
    cout << "Alignment:" << endl;
    for(int i=0; i<result.alignmentLength; i++) {
        cout << int(result.alignment[i]);
    }
    cout << endl;
#endif

    // Fill in the alignment.
    alignment.ordinals.clear();
    uint32_t ordinal0 = 0;
    uint32_t ordinal1 = 0;
    for(int i=0; i<result.alignmentLength; i++) {
        const unsigned char code = result.alignment[i];
        switch(code) {
        case EDLIB_EDOP_MATCH:
            alignment.ordinals.push_back({ordinal0++, ordinal1++});
            break;
        case EDLIB_EDOP_MISMATCH:
            ++ordinal0;
            ++ordinal1;
            break;
        case EDLIB_EDOP_INSERT:
            ++ordinal0;
            break;
        case EDLIB_EDOP_DELETE:
            ++ordinal1;
            break;
        default:
            SHASTA_ASSERT(0);
        }

    }
    // Free the alignment object.
    edlibFreeAlignResult(result);

    // Store the alignment info.
    alignmentInfo.create(alignment, uint32_t(markers0.size()), uint32_t(markers1.size()));
}

#pragma GCC diagnostic pop
